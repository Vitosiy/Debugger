03.11.2020


С использованием интерфейса Windows Debug API и библиотеки udis86 реализовать инструмент динамического исследования бинарного кода. Соответствующие сборки программы должны поддерживать 32-х и 64-х битное окружение.
Некоторые задания предполагают логирование в файл. Для каждого задания необходимо заводить отдельный файл, имя которого должно формироваться из имени программы, идентификатора процесса, идентификатора потока и времени начала логирования.
Возможно, что задания будут мешать друг другу, поэтому необходимо иметь возможность произвольно включать/выключать функциональность отдельных заданий.
Для тестирования найти или написать программы, которые позволят продемонстрировать весь реализованный функционал.


n - номер студента в списке (ориентироваться на список с оценками). =3
a=19
b=11


Базовая функциональность (к сдаче не принимаются задания с функциональностью меньше базовой).
15 баллов.
Требования:
1. Должна быть возможность запускать указанную программу под отладкой и присоединяться к указанному процессу.
2. 32-х битная сборка программы должна отлаживать 32-х разрядные программы. 64-х битная сборка программы должна отлаживать 64-х разрядные программы. Соответственно везде, где это необходимо, должна обеспечиваться (скорее всего с помощью директив условной компиляции) поддержка двух разрядностей: для кода, для регистрового контекста, для PE-формата и т.д.
3. Должна быть поддержка многопоточных программ: вся реализуемая функциональность должна выполняться для всех существующих и вновь порождаемых потоков.
4. С помощью отладочного интерфейса реализовать трассировку (с использованием флага трассировки) исследуемой программы на уровне отдельных инструкций. Необходимо отслеживать отдельные инструкции. Необходимо выбрать из приведенных ниже наборов инструкций один с номером (n*a+b)%18 = 14. В документации необходимо найти все инструкции, относящиеся к набору, для всех возможных разрядностей. В потоке всех трассируемых инструкций необходимо находить (придумать как это сделать) все инструкции из набора (остальные инструкции должны игнорироваться). Для каждой найденной инструкции сохранять в лог-файле запись со следующей информацией: дизассемблированная инструкция, регистровый контекст.
Наборы инструкций:
0) Все инструкции mov.
1) Все строковые инструкции: movs, cmps, scas, lods, stos.
2) Все инструкции call ближнего вызова функции. Все инструкции jmp безусловного перехода.
3) Все инструкции условного перехода.
4) Все инструкции ret, retn возврата из ближнего вызова функции.
5) Все инструкции sub/add.
6) Все инструкции mul/imul.
7) Все инструкции div/idiv.
8) Все инструкции xor/or/and.
9) Все инструкции cmp/test.
10) Все инструкции int/sysenter/syscall.
11) Все инструкции push/pop.
12) Все инструкции pusha/popa/pushf/popf.
13) Все инструкции rcl/rcr.
+14) Все инструкции rol/ror.+
15) Все инструкции sal/sar.
16) Все инструкции shl/shr.
17) Все инструкции xadd/xchg.


Дополнительные задания.

1. В случае реализации функциональности помимо базовой это дополнительное задание обязательно для исполнения.

Из списка ниже необходимо выбрать один набор с индексом (n*a+b)%9. =5 С помощью программных точек останова необходимо перехватывать все функции из набора. Необходимо выставить точки останова на нужные функции, отлавливать их срабатывание, при срабатывании правильно обрабатывать. Необходимо придумать корректный способ выполнения инструкции, перетёртой точкой останова. Выполнение перетертой инструкции можно эмулировать. Либо можно останавливать все потоки, восстанавливать перетертую инструкцию, делать один шаг трассировки, восстанавливать точку останова, запускать потоки.
Функции для перехвата находятся в системных библиотеках kernel32.dll, ntdll.dll. Эти библиотеки загружены во все процессы по одним адресам. Поэтому адреса функций можно получать в процессе отладчика с помощью GetProcAddress и эти адреса будут корректны в отлаживаемых процессах.
Необходимо придумать способ получения управления после возврата из функции (для получения возвращаемого значения и выходных аргументов).
Необходимо анализировать (для вывода) аргументы функции: входные при срабатывании точки останова, выходные - после возврата из функции. Анализ аргументов должен быть глубоким (т.е. с разыменованием указателей, разбором структур, учётом типов): например, для указателя на строку должна быть выведена строка, для массива (указателя на массив) - все элементы этого массива, для набора битовых флагов - имена выставленных флагов, для последовательности структур - все структуры в последовательности, для хендлов - имена и т.д. Должен быть настраиваемый предел максимального количества выводимых символов строки и элементов массива.
Если какой-то аргумент (или совокупность аргументов) определяет интерпретацию других аргументов (например, как аргумент FileInformationClass в функции ZwQueryInformationFile), то необходимо в зависимости от значения этого аргумента осуществлять различный разбор зависимых аргументов (в соответствии с описанием в документации - недокументированные коды и структуры не обрабатывать).
Разбор структур должен осуществляться на два уровня вложенности: если аргумент является указателем на структуру, то выводить все поля этой структуры в соответствии с их типом, если в этой структуре есть другая структура (как подструктура или указатель на структуру), то выводить и её поля в соответствии с их типом.
Т.е. необходимо выводить максимально полную доступную информацию о произошедшем вызове. Но для упрощения глубина вложенности ограничена двумя (только это может являться ограничением для получения полной информации).
Выводить в лог-файл следующую информацию: имя функции, аргументы функции (разобранные как сказано выше), возвращаемое значение, адрес возврата. Предложить и реализовать максимально наглядный вариант форматирования этой информации.
Наборы функций:
0) CreateFileA/CreateFileW, OpenFileA/OpenFileW, CreateFileMappingA/CreateFileMappingW, CloseHandle.
1) MapViewOfFile, MapViewOfFileEx, UnmapViewOfFile, ReadFile, WriteFile.
2) VirtualAlloc, VirtualAllocEx, VirtualFree, VirtualFreeEx, VirtualQuery, VirtualQueryEx, VirtualProtect, VirtualProtectEx.
3) HeapCreate, HeapDestroy, HeapAlloc, HeapFree, HeapSize, HeapReAlloc, HeapQueryInformation.
4) ZwQueryInformationFile
+5) ZwQuerySystemInformation+
6) ZwQueryDirectoryFile
7) CreateProcessA/CreateProcessW, CreateProcessAsUserA/CreateProcessAsUserW, ExitProcess, TerminateProcess.
8) CreateThread, ExitThread, CreateRemoteThread, OpenThread, GetThreadContext, SetThreadContext, SuspendThread, ResumeThread.

До 10 баллов.+
+5 баллов за унифицированный формат хранения информации о типах и функциях и обработку аргументов в одной общей функции без ограничения уровня вложенности.+


Из следующих дополнительных заданий необходимо выбрать не более двух заданий (нельзя одновременно выбирать 2 и 3 задания).


2. Статическое определение функций программы. Трассировка на уровне функций (с помощью точек останова).
Придумать алгоритм, который позволит при инициализации с помощью дизассемблирования найти все (по возможности) функции программы (в кодовых секциях PE-файла программы). Поставить точки останова на все функции и все точки выхода из функций. Придумать эвристический алгоритм поиска инструкции вызова функции при срабатывании точки останова в её начале. При заходе в функцию выводить в лог-файл следующую информацию: инструкцию вызова и её адрес, адрес функции. При выходе из функции выводить в лог-файл следующую информацию: возвращаемое значение, адрес возврата.

До 10 баллов.


3. Трассировка (с помощью флага трассировки) с динамическим определением функций программы.
Функции находить эвристически: трассировать все инструкции, по инструкции call находить начало функции (в PE-файле программы), по инструкции ret - конец. Придумать эвристический алгоритм, позволяющий определить количество аргументов функции (предполагать нотации cdecl, stdcall, fastcall для x64). При заходе в функцию выводить в лог-файл следующую информацию: инструкцию вызова и её адрес, адрес функции, аргументы функции. При выходе из функции выводить в лог-файл следующую информацию: возвращаемое значение, адрес возврата.

До 10 баллов.+


4. Трассировка (с помощью точек останова) библиотечных функций.
Найти все загруженные в отлаживаемый процесс библиотеки (эта информация предоставляется через отладочные сообщения). Разобрать таблицы экспорта этих библиотек и найти все экспортируемые функции. Поставить точки останова на все экспортируемые функции. Придумать эвристический алгоритм раскручивания стека для получения stack trace (предполагать нотации cdecl, stdcall, fastcall для x64) с адресами возврата, возможными аргументами и содержимым стекового фрейма. При срабатывании точки останова выводить в лог-файл следующую информацию: имя библиотеки, имя функции, адрес функции, stack trace.

До 10 баллов.+


5. Проверка корректности работы с динамической памятью.
Перехватывать функции работы с динамической памятью (malloc, free, VirtualAlloc, HeapAlloc и др.) с помощью программных точек останова. Придумать и реализовать техники (с помощью перехвата этих функций и, возможно, модификации их поведения) детектирования ошибок работы с памятью:
- отсутствие проверки возвращаемого значения при выделении памяти;
- неправильный указатель при освобождении памяти;
- обращение к памяти после освобождения;
- двойное освобождение памяти;
- обращение за пределами выделенного блока (перед ним и после него);
- утечка памяти.

До 10 баллов.




Необходимые API функции:

запуск процесса под отладчиком
CreateProcess

подсоединение к процессу в качестве отладчика
DebugActiveProcess

чтение памяти
ReadProcessMemory

изменение памяти, установка программных точек останова (int 3)
WriteProcessMemory

получение значения регистров
GetThreadContext

изменение регистров, установка аппаратных точек останова
SetThreadContext



Примеры кода и шаблоны для задания в каталоге lab\5.

Пример peinfo анализирует 32-х и 64-х битные PE-файлы.

Описание отладочных регистров в главе 16.2 документа
"Intel 64 and IA-32 Architectures. Software Developer's Manual. Volume 3 (3A & 3B). System Programming Guide".
\\dc1\doc\books\computing\prog\hard\процессоры\intel\64-ia-32-architectures-software-developer-vol-3a-3b-system-programming-manual.pdf



Пример кода для определения номеров

a = 19
b = 11
for n in range(1, 18):
	print str(n) + ' ' + str((n*a+b)%18) + ' ' + str((n*a+b)%9)
